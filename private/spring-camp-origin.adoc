== 실전에 써먹는 스프링 부트 (김지헌)

Bootiful Your Life!?

http://honeymon.io

Netflix도 자바와 관련된 시스템은 스프링 부트로 전환했다.
Spring Boot - Spring Cloud - Spring Cloud Data Flow
개발자가 손쉽게 부트앱을 만들 수 있다고 스프링에서 홍보중

=== 스프링부트

스프링 프레임워크를 기반으로한 개발 플랫폼

==== 스프링 부트 구성요소

스프링 부트 스타터 - 스프링 프레임워크, 스프링 부트 - 빌드 도구(그레이들, 메이븐)

=== Gradle

Gradle Cross ??? - Multi module
Kotlin DSL과 Groovy DSL이 있음

==== Kotlin DSL

빠른 문서보기
크드 자동완성
에러 강조표시
코드 리팩토링

=== Spring Boot Gradle Plugin

의존성 관리
실행가능한 아카이브 패키징
애플리케이션 배포
애플리케이션 실행
액츄에이터 지원

=== BOM

Bill of Material로 인해 버전을 명시적으로 작성하지않음(호환 버전을 자동으로 import)
spring-boot-dependencies가 의존성 관리
`enforcePlatform`으로 다른 BOM 파일 가져올 수 있음


=== Code

`@Profile` 어노테이션으로 프로파일에 따라 다른 빈 설정 및 주입을 할 수 있음

스프링 부트 자동구성(AutoConfiguration)
`@Configuration`
`@Conditional~~`

애플리케이션 속성을 실행시점에 외부에서 변경한다.
* 실행 시점에 환경변수(?)로 주입
* `@ConfigurationProperties`
* 무슨 json 을 만들어냄

.ConfigurationProperties
[source,java]
----
@Component
@ConfigurationProperties(prefix = "example.tt")
class ExampleProperties {
  String name;
  String key;
}
----

아니 왜 자꾸 코틀린으로 보여주냐고
이럴거면 코틀린을 앞에 배치해놓던가
Actuator
접근 방식 HTTP or JMX


<<<

== Monitoring With Actuator (서경원)

* 11:35 ~ 12:20

=== Why & How Monitoring

* 장애 예방, 원인 파악, 조치
* 변경에 대한 상태 확인
* 성능 개선
* 장기적인 서비스 상태 분석
* 지표가 필요하다

지표를 어디서 획득? 어떻게 생성?

==== NHN 모니터링 시스템

* 서버 인프라 지표 수집
* 애플리케이션 지표 수집
* 모니터링 차트 제공
* 지표 감시 및 알림

=== Spring Boot Actuator

Spring Boot 애플리케이션 모니터링

* 제어 도구 제공 - endpoints
* 애플리케이션 지표 제공 - metrics

dependency 추가하면 AutoConfiguration에 의해서 자동으로 등록
여러 종류의 endpoints 를 제공
사용할 endpoints를 설정을 통해서 제어 가능 및 외부 노출 설정 가능
`enabled-by-default=false`로 해서 기본 사용 옵션을 끌 수 있음
Security로 endpoint 권한 설정 가능

=== Metrics Endpoint

jvm, jdbc, web, library 등 여러가지 metrics 제공

Boot1에서 계층형이었지만 2에서 Dimension구조로 변경(Tag를 붙입)
* 이해하기 쉬움
* 여러 관점에서 지표 분석 가능
* 유연함 손쉬운 Tag 추가/삭제

RED Method - 반드시 측정해야하는 metrics
* Request Rate
* Request Errors
* Request Duration

Hystrix - Circuit Breaker 장애 내성 / 지연 내성

=== Micrometer

dependency 추가 - AutoConfiguration
prometheus endpoint 추

=== Demo

<<<

== 자바에서 null을 안전히 다루는 방법 (박성철)

* 12:30 ~ 13:00

=== null에 대해서

.JVM 언어 전쟁
* 2000년대 중반 동적 티이핑/스크립팅 언어가 유행
* 2010년 전후 함수형 프로그래밍
* 2010년대 중반 null 안정성(실론, 코들린)

.null 참조
* 레코드 핸들링: 객체지향의 시초가 된 논문
* 특별한 값이 없음을 나타내려고 null을 도입했고 이 값을 사용하려고 할 때 오류를 내도록 설계
* 두 참조값이 null 일 때 두 참조는 동일하다고 판단

.자바의 null 참조
* 의미가 모호함
* 초기화되지 않음, 정의되지 않음, 값이 없음, null 값
* 모든 참조의 기본 상태(값?)
* 모든 참조는 null 가능

=== null을 안전하게 다루는 방법

.자바 기본 장치
* 단정문(assertion)
  * 공개 메서드에서 사용하지 않아야 함
  * 소비자이면서 생산자일 때 만 사용
  * enableassertions 또는 -ea 옵션으로 활성화
* java.util.Objects
  * null을 핸들링할 수 있는 메소드들이 추가
* java.util.Optional
  * 변수와 반환값에 null을 사용하지 말라
  * Optional에 값이 있다가 확신하지 않는 한 get을 사용하지 말라
  * isPresent나 get은 가능한 사용하지 말라
  * 필드 매개변수등으로는 사용하지 말라
    * 직렬화 불가
  * 반환값은 사용해도 된다

slides.app.goo.gl/i94DQ

.null 잘 쓰는 법
* API에 최대한 쓰지 말아라
  * null로 지나치게 유여한 메서드를 만들지 말고 명시적인 메서드를 만들어라
  * null을 반환하지 말ㄹ라
  * 반환 값이 꼭 있어야 한다면 null을 반환하지 말고 예외를 던져라
  * 빈 반환값은 Null 객체
* 사전조건과 사후조건을 확인하라: 계약에 의한 설계
  * Design by Contract
* null의 볌위를 지역(클래스 메서드)화

조용호(?) 객체지향 설계

Checker Framework

=== null에 안전하다고 보장해주는 도구

<<<

== 무엇을 테스트할 것인가? 어떻게 테스트할 것인가? (권용근)

* 14:00 ~ 14:45

co-duck.com

=== 테스트로부터 얻을 수 있는것

안정감과 자신감이 생긴다

=== 무엇을 테스트할 것인가?

비즈니스 요구사항 정리
구현 vs 설계
구현은 언젠가 변할 수 있고 테스트는 구현에서 무엇을 하는지 알 수 없고 알 필요도 없다

==== 테스트 가능한 것 불가능한 것

.테스트 불가능한 것
* 외부 요청
* 외부 저장소

=== 어떻게 테스트할 것인가?

테스트할 수 없는 것을 바운더리 레이어까지 올려서 피해를 최소화한다
제어할 수 없는 영역을 파라미터로 받을 수 있는지 검토한다
비즈니스 요구사항이 변경될 수 있다

==== Java, Spring Framework

테스트를 할 때 Spring Context가 굳이 필요하지 않다
테스트를 할 때 비즈니스 프레임워크에 의존하지 말라

==== Test Double

무엇을 Test Double로 처리?
테스트가 구현을 알아야 함?
제어할 수 없는 영역을 Test Double로 처리

==== Embedded

스프링에 내장된 시스템을 최대한 활용

==== Spring Cloud Contract

=== Tip & Rule

상호 독립적으로
테스트안에 의도가 드러날 수 있도록 해라
테스트코드도 리팩토링 대

Q. 수많은 요구사항을 담고있는 메소드(레거시) 테스트 경험?
테스트가 구현을 안다? 테스트는 스펙 -> 기능 설계를 함 -> Usecase 설계를 한다면 구현을 앎
테스트를 하나만 하는게 아니게 됨

<<<

== 당신도 할 수 있는 레거시 프로젝트 개선 이야기 (이경일)

* 15:00 ~ 15:45

=== 레거시 코드란?

* 막막한 코드?
* 복잡한 코드?
* 남(주로 퇴사자)이 짠 코드?

* 테스트코드로 커버되지 않으며 유지보수가 되고있지 않은 코드
* 방치되고있는 코드

* 오랜 시간 안정적으로 돌아가는 코드

=== 레거시 코드를 외면하는 이유?

* 다른사람이 짠 코드는 수정하기 싫다
* 신규프로젝트가 재밋다
* 조직에서 인정받기 어렵다

=== 레거시 코드 개선

* DDD? MSA?
* 내편으로 만들기
  * 왜 이렇게만들었어 지만 잘 동작은 하고 있음...
  * 로직 파악하기
  * 직접 돌려보는 것이 중요
  * 테스트 케이스를 봐야함
* 급한불부터 끄기
  * 리팩토링
  * 우선순위 정하기
  * 불필요하거나 수정하기 어려운(?) 것은 과감하게 삭제
* 한걸음씩 가기
  * 코드 패키지 분리
  * 분리가 용이하도록 설계
  * 코드를 분리할 수 있는 부분은 분리
  * 개선을 하면서 커지면 또 분리
* 아픈 곳 고치기
  * 리소스 사용량이 많은 부분은 추출
  * 로컬 캐시를 사용할 수 있는 부분은 로컬캐시를 사용
  * Memory Leak이 있는지 검토(?)
  * Matcher_AppendReplacement -> http://bit.ly/2lOezox
  * OOM Killer
  * ~.~.2 이상만 쓰자
* 조금 더 다듬기
  * RAM Drive를 사용할 수 있는가?
  * Spring Cloud Config
    * basedir 수정

=== ETC

Nginx Traffic Throttling
Graceful Shutdown
GC 튜닝

TC는 TC일뿐 직접 사용해봐
`@Cacheable`

== Coffee Break

* 15:45 ~ 16:15

== 멀티리전 가용성을 위한 글로벌 캐싱 - Hidden micro services (정윤진, 김필중)

* 16:15 ~ 17:00

== Local Cache와 Invalidation Message Propagation 전략을 활용하여 API 성능 튜닝하기 (김민규)

* 17:15 ~ 18:00